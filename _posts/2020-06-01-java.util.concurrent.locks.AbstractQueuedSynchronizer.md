---
layout: article
title: java AbstractQueuedSynchronizer源码深入解析
date: 2020-06-01 21:47:43 +0800
categories: java
tags: jdk14 源码
---
本文尝试详细阐述一下jdk14的[AbstractQueuedSynchronizer](http://hg.openjdk.java.net/jdk/jdk/file/jdk-14-ga/src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java){:target="_blank"}源码。
[jdk6](http://hg.openjdk.java.net/jdk6/jdk6/jdk/file/default/src/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java){:target="_blank"}
[jdk7](http://hg.openjdk.java.net/jdk/jdk/file/jdk7-b100/jdk/src/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java){:target="_blank"}

此类提供了一个加锁解锁的框架，它的内部会维护一个先进先出的同步队列，如果使用了Condition的话，每个Condition内部还会维护一个条件队列。

同步队列的head指向的节点是一个假节点，该节点在初始化的时候是一个ExclusiveNode节点，有节点争抢锁的时候，head就会指向抢到了锁的节点，但会清理掉线程标记。

使用Condition的时候，如果某个线程调用条件对象的await方法，那么该线程会释放持有的锁，然后去该节点所在的条件队列中排队，等待被唤醒。
当条件满足后，其它线程会调用signal/signalAll唤醒等待的线程，被唤醒的线程又会去同步队列中排队，等待抢锁的机会。


##### 定义

这个类居然还支持序列化。
{% highlight java linenos %}
public abstract class AbstractQueuedSynchronizer
    extends AbstractOwnableSynchronizer
    implements java.io.Serializable
{% endhighlight %}


##### 构造方法

没做啥事，只能由子类来构造。
{% highlight java linenos %}
protected AbstractQueuedSynchronizer() { }
{% endhighlight %}

##### 状态常量

有英文注释，基本不用解释。

{% highlight java linenos %}
static final int WAITING   = 1;          // must be 1
static final int CANCELLED = 0x80000000; // must be negative
static final int COND      = 2;          // in a condition wait
{% endhighlight %}


##### 同步队列中的线程封装

线程、状态、同步队列的封装。

{% highlight java linenos %}
/** CLH Nodes */
abstract static class Node {
    volatile Node prev;       // initially attached via casTail                  同步队列中当前节点的前一个节点
    volatile Node next;       // visibly nonnull when signallable                同步队列中当前节点的后一个节点
    Thread waiter;            // visibly nonnull when enqueued                   当前节点对应的线程
    volatile int status;      // written by owner, atomic bit ops by others      当前节点的状态

    // methods for atomic operations
    final boolean casPrev(Node c, Node v) {  // for cleanQueue     相当于  if（this.prev == c) this.prev = v;
        return U.weakCompareAndSetReference(this, PREV, c, v);
    }
    final boolean casNext(Node c, Node v) {  // for cleanQueue     相当于  if（this.next == c) this.next = v;
        return U.weakCompareAndSetReference(this, NEXT, c, v);  
    }
    final int getAndUnsetStatus(int v) {     // for signalling       相当于 this.status = this.status & ~v;
        return U.getAndBitwiseAndInt(this, STATUS, ~v);
    }
    final void setPrevRelaxed(Node p) {      // for off-queue assignment  相当于 this.prev = p;
        U.putReference(this, PREV, p);
    }
    final void setStatusRelaxed(int s) {     // for off-queue assignment  相当于 this.status = s;
        U.putInt(this, STATUS, s);
    }
    final void clearStatus() {               // for reducing unneeded signals    相当于 this.status = 0;
        U.putIntOpaque(this, STATUS, 0);
    }

    private static final long STATUS
        = U.objectFieldOffset(Node.class, "status");
    private static final long NEXT
        = U.objectFieldOffset(Node.class, "next");
    private static final long PREV
        = U.objectFieldOffset(Node.class, "prev");
}
{% endhighlight %}



##### 节点对应的锁类型

表明线程持有的锁的类型。比jdk8的表示方式要优雅。

{% highlight java linenos %}
static final class ExclusiveNode extends Node { }
static final class SharedNode extends Node { }
{% endhighlight %}


##### 条件队列中的线程封装

{% highlight java linenos %}

static final class ConditionNode extends Node
    implements ForkJoinPool.ManagedBlocker {
    ConditionNode nextWaiter;            // link to next waiting node          指向下一个节点，串起整个同步队列

    /**
        * Allows Conditions to be used in ForkJoinPools without
        * risking fixed pool exhaustion. This is usable only for
        * untimed Condition waits, not timed versions.
        */
    public final boolean isReleasable() {    //线程状态不为COND，或者线程被中断了，不能放在条件队列中
        return status <= 1 || Thread.currentThread().isInterrupted();
    }

    public final boolean block() {
        while (!isReleasable()) LockSupport.park();            //当前线程暂停，直到被其它线程唤醒
        return true;                                           //唤醒后继续从这里执行
    }
}
{% endhighlight %}


##### 同步队列

{% highlight java linenos %}
    /**
     * Head of the wait queue, lazily initialized.       同步队列，指向的第一个节点一般是抢到了锁的节点，后面的节点是没有抢到的
     */
    private transient volatile Node head;

    /**
     * Tail of the wait queue. After initialization, modified only via casTail.
     */
    private transient volatile Node tail;

{% endhighlight %}


##### 同步状态

AQS本身不操作这个变量，这个变量的意思由子类定义和使用。一般就是持有锁的线程数量或重入次数。
{% highlight java linenos %}
    /**
     * The synchronization state.
     */
    private volatile int state;
{% endhighlight %}


##### 同步状态

初始化同步队列，其实就是设置头（head）和尾（tail）都设置为一个假节点。
从这里可以看出，除非队列没有初始化，否则head和tail都不会为空的，也可以看出来，当head == tail的时候，队列为空。
{% highlight java linenos %}
/** tries once to CAS a new dummy node for head */
private void tryInitializeHead() {
    Node h = new ExclusiveNode();
    if (U.compareAndSetReference(this, HEAD, null, h))
        tail = h;
}
{% endhighlight %}


##### 节点进入同步队列

看起来比较复杂，其实就是将新节点排到队尾。

+ 原队尾.next = 新节点（新队尾）
+ 新节点（新队尾）.prev = 原队尾
+ 队尾指针tail = 新节点（新队尾）

{% highlight java linenos %}
/**
    * Enqueues the node unless null. (Currently used only for
    * ConditionNodes; other cases are interleaved with acquires.)
    */
final void enqueue(Node node) {
    if (node != null) {
        for (;;) {
            Node t = tail;                 // 原来的队尾
            node.setPrevRelaxed(t);        // avoid unnecessary fence node.prev = tail;  当前节点变成新队尾了，所以当前节点的前置节点就指向了原队尾
            if (t == null)                 // initialize 队列还没有初始化
                tryInitializeHead();
            else if (casTail(t, node)) {   //     this.tail = node;  将队尾设置为当前节点
                t.next = node;             //     tail.next = node;  原来的队尾不是队尾了，后面挂着当前节点了
                if (t.status < 0)          // wake up to clean link 原队尾节点被取消了
                    LockSupport.unpark(node.waiter);              //唤醒当前节点对应的线程 （？）
                break;
            }
        }
    }
}
{% endhighlight %}


##### 节点是否已经在同步队列中

{% highlight java linenos %}
/** Returns true if node is found in traversal from tail */
final boolean isEnqueued(Node node) {
    for (Node t = tail; t != null; t = t.prev)
        if (t == node)
            return true;
    return false;
}
{% endhighlight %}


##### 唤醒后续的等待节点

当节点释放锁的时候，会唤醒后面的一个线程。

{% highlight java linenos %}
/**
    * Wakes up the successor of given node, if one exists, and unsets its
    * WAITING status to avoid park race. This may fail to wake up an
    * eligible thread when one or more have been cancelled, but
    * cancelAcquire ensures liveness.
    */
private static void signalNext(Node h) {
    Node s;
    if (h != null && (s = h.next) != null && s.status != 0) {  //status=0表示节点刚刚初始化
        s.getAndUnsetStatus(WAITING);          //取消等待标志
        LockSupport.unpark(s.waiter);          //唤醒下一个节点对应的线程
    }
}
{% endhighlight %}


##### 唤醒后续的等待共享锁的节点

当线程获取到共享锁到时候，它会看看后面的线程是不是在等共享锁，是的话就唤醒它。

如果新唤醒的线程也拿到了共享锁了，它也会尝试唤醒后面等共享锁的线程。

{% highlight java linenos %}
/** Wakes up the given node if in shared mode */
private static void signalNextIfShared(Node h) {
    Node s;
    if (h != null && (s = h.next) != null &&
        (s instanceof SharedNode) && s.status != 0) {
        s.getAndUnsetStatus(WAITING);
        LockSupport.unpark(s.waiter);
    }
}
{% endhighlight %}


##### 排队并抢锁

{% highlight java linenos %}
/**
    * Main acquire method, invoked by all exported acquire methods.
    *
    * @param node null unless a reacquiring Condition
    * @param arg the acquire argument
    * @param shared true if shared mode else exclusive
    * @param interruptible if abort and return negative on interrupt
    * @param timed if true use timed waits
    * @param time if timed, the System.nanoTime value to timeout
    * @return positive if acquired, 0 if timed out, negative if interrupted
    */
final int acquire(Node node, int arg, boolean shared,
                    boolean interruptible, boolean timed, long time) {
    Thread current = Thread.currentThread();
    byte spins = 0, postSpins = 0;   // retries upon unpark of first thread
    boolean interrupted = false, first = false;
    Node pred = null;                // predecessor of node when enqueued

    /*
        * Repeatedly:
        *  Check if node now first
        *    if so, ensure head stable, else ensure valid predecessor
        *  if node is first or not yet enqueued, try acquiring
        *  else if node not yet created, create it
        *  else if not yet enqueued, try once to enqueue
        *  else if woken from park, retry (up to postSpins times)
        *  else if WAITING status not set, set and retry
        *  else park and clear WAITING status, and check cancellation
        */

    for (;;) { 
        if (!first /*条件1*/ && (pred = (node == null) ? null : node.prev) != null /*条件2*/ &&
            !(first = (head == pred)) /*条件3*/) {
            // 条件1:  第1次循环的时候，first=false，不会到这个分支；
            //        第2次循环的时候，如果node=null（不是从条件队列转过来的），那么，pred=null，也不会到这个分支，只能等第3次循环才看看有机会不；
            //                      如果是从条件队列转过来的，那么第2次循环可能会进这个分支
            // 条件2:  node=null表示不是从条件队列转过来的；node不为空，已经在本循环中被初始化了，或者是从条件队列转过来的。
            //        node.prev=null有2中可能，1是node已经排在第1位了（head指向的节点的后面），另外一个就是还没有同步队列
            // 条件3:  first唯一重新赋值的地方，到了此处说明pred！=null，如果first=true，那么说明同步队列已经初始化了，并且node排在了第1位
            // 进到这个分支，表明节点已经加入到同步队列了，并且不是排在第1位
            if (pred.status < 0) {  //前置节点被取消了
                cleanQueue();           // predecessor cancelled  删掉所有取消的节点
                continue;
            } else if (pred.prev == null) {       //前置节点前置不在队列中，可能正在被删除
                Thread.onSpinWait();    // ensure serialization
                continue;
            }
        }                               
        if (first || pred == null) {    
            // 第1次循环的时候，first=false，但pred=null，所以第1次循环会进这个分支；
            // 以后的循环中，节点可能排到了第1位，也可以进这个分支
            // pred！=null表示节点加入了同步队列了
            boolean acquired;
            try {
                if (shared)
                    acquired = (tryAcquireShared(arg) >= 0);
                else
                    acquired = tryAcquire(arg);
            } catch (Throwable ex) {
                cancelAcquire(node, interrupted, false);      //出异常了，取消节点
                throw ex;
            }
            if (acquired) {      // 抢到锁了
                if (first) {     // true：当前节点排在了第一位，排在队伍中间的不用；false：节点还没初始化或者刚初始化但还没进入队列就抢到锁了，太幸运了
                    node.prev = null; //清理prev
                    head = node;      //head直接指向获取锁的节点，原来的节点自然就从队头移除了
                    pred.next = null;
                    node.waiter = null;
                    if (shared)
                        signalNextIfShared(node);    //如果抢到了共享锁，就唤醒一下后面的节点，看看能一起共享不？
                    if (interrupted)    //当前节点被中断了
                        current.interrupt();
                }
                return 1;  //大于0，正常抢到锁，退出本方法
            }
        }
        if (node == null) { // allocate; retry before enqueue 节点没有初始化，先初始化，然后在下一个循环中开始排队、抢锁
            if (shared)
                node = new SharedNode();       //初始化节点
            else
                node = new ExclusiveNode();    //初始化节点
        } else if (pred == null) {          // try to enqueue 没有进入同步队列，也没有抢到锁，那就进入同步队列去排队。
                                            // 看到没？节点初始化和节点进入队列是在不同的循环里面完成的。
            node.waiter = current;
            Node t = tail;
            node.setPrevRelaxed(t);         // avoid unnecessary fence
            if (t == null)
                tryInitializeHead();
            else if (!casTail(t, node))
                node.setPrevRelaxed(null);  // back out
            else
                t.next = node;
        } else if (first && spins != 0) {
            --spins;                        // reduce unfairness on rewaits
            Thread.onSpinWait();
        } else if (node.status == 0) {
            node.status = WAITING;          // enable signal and recheck             没抢到锁，但进入了同步队列了，改一下状态
        } else {
            long nanos;
            spins = postSpins = (byte)((postSpins << 1) | 1);       // postSpins=1,3,7,15,31,63,127,-1,-1,...
            if (!timed)           //不用考虑超时
                LockSupport.park(this);           //就一直休眠，一直等到被signalNext或signalNextIfShared唤醒。
                                                  // 唤醒之后，如该线程未被中断，则继续在acquire方法的循环中进行下一轮抢锁、休眠、被唤醒。
            else if ((nanos = time - System.nanoTime()) > 0L)
                LockSupport.parkNanos(this, nanos);  //响应超时版的休眠
            else
                break;
            node.clearStatus();
            if ((interrupted |= Thread.interrupted()) && interruptible)    //被中断了， 跳出循环，调用cancelAcquire取消排队。
                break;
        }
    }
    return cancelAcquire(node, interrupted, interruptible);
}
{% endhighlight %}


##### 清理同步队列中所有已经被取消的节点

{% highlight java linenos %}
/**
    * Possibly repeatedly traverses from tail, unsplicing cancelled
    * nodes until none are found. Unparks nodes that may have been
    * relinked to be next eligible acquirer.
    */
private void cleanQueue() {
    for (;;) {                               // restart point  外部的循环，当从队尾清理至队首后就退出。
                                             // 内部的循环，一次最多清理一个被取消的节点，每次都是从队尾开始往队首清理。
        for (Node q = tail, s = null, p, n;;) { // (p, q, s) triples  q从队尾遍历至队首，s指向q后面的一个节点，p指向q前面的节点，n指向p后面的节点
            if (q == null || (p = q.prev) == null)
                return;                      // end of list
            if (s == null ? tail != q : (s.prev != q || s.status < 0))
                break;                       // inconsistent
            if (q.status < 0) {              // cancelled
                if ((s == null      /* s == null 表示在调整队尾 */
                    ? casTail(q/*当前节点*/, p/*前置节点*/) /*tail向前挪动一位*/ 
                    : s/*后置节点*/.casPrev(q/*当前节点*/, p/*前置节点*/) /* 后置节点的prev向前挪动一位*/) 
                    && q/*当前节点*/.prev == p/*前置节点*/) {        /* q p的关系没有变，没其它线程干扰 */
                    p/*前置节点*/.casNext(q/*当前节点*/, s/*后置节点*/);         // OK if fails    前置节点的next向后挪动一位 
                    if (p.prev == null)
                        signalNext(p);
                }
                break;
            }
            if ((n/* 前置节点的后置节点 */ = p/*前置节点*/.next) != q/*当前节点*/) {         // help finish   前置节点的后置节点居然不是当前节点
                if (n != null && q/*当前节点*/.prev == p/*前置节点*/) {      // q的prev指向了p，但p的next却不是q，需要修复，让p.next=q
                    p/*前置节点*/.casNext(n, q/*当前节点*/);                 // if (p.next == n) p.next = q;  这里就是修复，让p.next=q
                    if (p.prev == null)
                        signalNext(p);
                }
                break;       //前置节点的后置节点居然不是当前节点，看来是被其它线程干扰了
            }
            s = q;
            q = q.prev;
        }
    }
}
{% endhighlight %}


##### 取消当前任务

取消当前任务，如果当前任务已经在同步队列中了，顺便也清理同步队列中已经被取消的任务

{% highlight java linenos %}
/**
    * Cancels an ongoing attempt to acquire.
    *
    * @param node the node (may be null if cancelled before enqueuing)
    * @param interrupted true if thread interrupted
    * @param interruptible if should report interruption vs reset
    */
private int cancelAcquire(Node node, boolean interrupted,
                            boolean interruptible) {
    if (node != null) {
        node.waiter = null;
        node.status = CANCELLED;
        if (node.prev != null)
            cleanQueue();
    }
    if (interrupted) {
        if (interruptible)
            return CANCELLED;
        else
            Thread.currentThread().interrupt();
    }
    return 0;
}
{% endhighlight %}


##### 尝试获取独占锁

尝试获取独占锁。如果需要实现独占锁功能，那么子类就需要实现这个方法。

这个方法只有一个参数，值与调用public final void acquire(int arg)的参数值相同，AQS不理解这个参数值。

实现这个方法时，如果返回true，则表示独占锁获取成功，否则表示失败。

{% highlight java linenos %}
protected boolean tryAcquire(int arg) {
    throw new UnsupportedOperationException();
}
{% endhighlight %}


##### 尝试释放独占锁

尝试释放独占锁。如果需要实现独占锁功能，那么子类就需要实现这个方法。

这个方法只有一个参数，值与调用public final void release(int arg)的参数值相同，AQS不理解这个参数值。

实现这个方法时，如果返回true，则表示独占锁释放成功，否则表示失败。

{% highlight java linenos %}
protected boolean tryRelease(int arg) {
    throw new UnsupportedOperationException();
}
{% endhighlight %}


##### 尝试获取共享锁

尝试获取共享锁。如果需要实现共享锁功能，那么子类就需要实现这个方法。

这个方法只有一个参数，值与调用public final void acquireShared(int arg)的参数值相同，AQS不理解这个参数值。

实现这个方法时，如果返回值小于0则表示失败，等于0表示当前节点获取锁成功，大于0表示当前节点和后续节点都获取锁成功。

{% highlight java linenos %}
protected int tryAcquireShared(int arg) {
    throw new UnsupportedOperationException();
}
{% endhighlight %}


##### 尝试释放共享锁

尝试释放共享锁。如果需要实现共享锁功能，那么子类就需要实现这个方法。

这个方法只有一个参数，值与调用public final void releaseShared(int arg)的参数值相同，AQS不理解这个参数值。

实现这个方法时，如果返回true，则表示独共享锁释放成功，否则表示失败。

{% highlight java linenos %}
protected boolean tryReleaseShared(int arg) {
    throw new UnsupportedOperationException();
}
{% endhighlight %}



##### 当前线程是否拥有独占锁

{% highlight java linenos %}
protected boolean isHeldExclusively() {
    throw new UnsupportedOperationException();
}
{% endhighlight %}


##### 获取独占锁

不响应中断。

{% highlight java linenos %}
public final void acquire(int arg) {
    if (!tryAcquire(arg))
        acquire(null, arg, false, false, false, 0L);
}
{% endhighlight %}



##### 获取独占锁

可以响应中断。

{% highlight java linenos %}
public final void acquireInterruptibly(int arg)
    throws InterruptedException {
    if (Thread.interrupted() ||
        (!tryAcquire(arg) && acquire(null, arg, false, true, false, 0L) < 0))
        throw new InterruptedException();
}
{% endhighlight %}


##### 获取独占锁

可以响应中断和超时。

{% highlight java linenos %}
public final boolean tryAcquireNanos(int arg, long nanosTimeout)
    throws InterruptedException {
    if (!Thread.interrupted()) {
        if (tryAcquire(arg))
            return true;
        if (nanosTimeout <= 0L)
            return false;
        int stat = acquire(null, arg, false, true, true,
                            System.nanoTime() + nanosTimeout);
        if (stat > 0)
            return true;
        if (stat == 0)
            return false;
    }
    throw new InterruptedException();
}
{% endhighlight %}



##### 释放独占锁

并且唤醒排在前面的等待节点。

{% highlight java linenos %}
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        signalNext(head);
        return true;
    }
    return false;
}
{% endhighlight %}


##### 获取共享锁

不响应中断。

{% highlight java linenos %}
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) < 0)
        acquire(null, arg, true, false, false, 0L);
}
{% endhighlight %}



##### 获取共享锁

响应中断。

{% highlight java linenos %}
public final void acquireSharedInterruptibly(int arg)
    throws InterruptedException {
    if (Thread.interrupted() ||
        (tryAcquireShared(arg) < 0 &&
            acquire(null, arg, true, true, false, 0L) < 0))
        throw new InterruptedException();
}
{% endhighlight %}


##### 获取共享锁

响应中断和超时。

{% highlight java linenos %}
public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    if (!Thread.interrupted()) {
        if (tryAcquireShared(arg) >= 0)
            return true;
        if (nanosTimeout <= 0L)
            return false;
        int stat = acquire(null, arg, true, true, true,
                            System.nanoTime() + nanosTimeout);
        if (stat > 0)
            return true;
        if (stat == 0)
            return false;
    }
    throw new InterruptedException();
}
{% endhighlight %}



##### 释放共享锁

并且唤醒排在前面的等待节点。

{% highlight java linenos %}
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        signalNext(head);
        return true;
    }
    return false;
}
{% endhighlight %}



##### 查询同步队列中是否有等待锁的线程

{% highlight java linenos %}
public final boolean hasQueuedThreads() {
    for (Node p = tail, h = head; p != h && p != null; p = p.prev)
        if (p.status >= 0)
            return true;
    return false;
}
{% endhighlight %}


##### 查询是否有节点排队过

从来没节点排过队的话，head变量是不会初始化的。初始化了以后，head变量就不会为null了。

{% highlight java linenos %}   
 /**
    * Queries whether any threads have ever contended to acquire this
    * synchronizer; that is, if an acquire method has ever blocked.
    *
    * <p>In this implementation, this operation returns in
    * constant time.
    *
    * @return {@code true} if there has ever been contention
    */
public final boolean hasContended() {
    return head != null;
}
{% endhighlight %}


##### 查询排在队首队节点

{% highlight java linenos %}   
    /**
    * Returns the first (longest-waiting) thread in the queue, or
    * {@code null} if no threads are currently queued.
    *
    * <p>In this implementation, this operation normally returns in
    * constant time, but may iterate upon contention if other threads are
    * concurrently modifying the queue.
    *
    * @return the first (longest-waiting) thread in the queue, or
    *         {@code null} if no threads are currently queued
    */
public final Thread getFirstQueuedThread() {
    Thread first = null, w; Node h, s;
    if ((h = head) != null && ((s = h.next) == null ||
                                (first = s.waiter) == null ||
                                s.prev == null)) {
        // traverse from tail on stale reads
        for (Node p = tail, q; p != null && (q = p.prev) != null; p = q)
            if ((w = p.waiter) != null)
                first = w;
    }
    return first;
}

{% endhighlight %}

##### 判断指定线程是否在同步队列中

{% highlight java linenos %}   
/**
    * Returns true if the given thread is currently queued.
    *
    * <p>This implementation traverses the queue to determine
    * presence of the given thread.
    *
    * @param thread the thread
    * @return {@code true} if the given thread is on the queue
    * @throws NullPointerException if the thread is null
    */
public final boolean isQueued(Thread thread) {
    if (thread == null)
        throw new NullPointerException();
    for (Node p = tail; p != null; p = p.prev)
        if (p.waiter == thread)
            return true;
    return false;
}

{% endhighlight %}


##### 判断同步队列的队首是否是共享锁节点

{% highlight java linenos %}   
/**
    * Returns {@code true} if the apparent first queued thread, if one
    * exists, is waiting in exclusive mode.  If this method returns
    * {@code true}, and the current thread is attempting to acquire in
    * shared mode (that is, this method is invoked from {@link
    * #tryAcquireShared}) then it is guaranteed that the current thread
    * is not the first queued thread.  Used only as a heuristic in
    * ReentrantReadWriteLock.
    */
final boolean apparentlyFirstQueuedIsExclusive() {
    Node h, s;
    return (h = head) != null && (s = h.next)  != null &&
        !(s instanceof SharedNode) && s.waiter != null;
}
{% endhighlight %}

##### 判断同步队列中是否有线程在排队

用于公平锁。非公平锁的节点不会看是否有其它线程在排队等待锁的。

{% highlight java linenos %}

public final boolean hasQueuedPredecessors() {
    Thread first = null; Node h, s;
    if ((h = head) != null && ((s = h.next) == null ||
                                (first = s.waiter) == null ||
                                s.prev == null))
        first = getFirstQueuedThread(); // retry via getFirstQueuedThread
    return first != null && first != Thread.currentThread();
}


{% endhighlight %}

##### 获取同步队列的长度

{% highlight java linenos %}
// Instrumentation and monitoring methods

/**
    * Returns an estimate of the number of threads waiting to
    * acquire.  The value is only an estimate because the number of
    * threads may change dynamically while this method traverses
    * internal data structures.  This method is designed for use in
    * monitoring system state, not for synchronization control.
    *
    * @return the estimated number of threads waiting to acquire
    */
public final int getQueueLength() {
    int n = 0;
    for (Node p = tail; p != null; p = p.prev) {
        if (p.waiter != null)
            ++n;
    }
    return n;
}

{% endhighlight %}


##### 获取在同步队列中排队的线程

{% highlight java linenos %}

/**
    * Returns a collection containing threads that may be waiting to
    * acquire.  Because the actual set of threads may change
    * dynamically while constructing this result, the returned
    * collection is only a best-effort estimate.  The elements of the
    * returned collection are in no particular order.  This method is
    * designed to facilitate construction of subclasses that provide
    * more extensive monitoring facilities.
    *
    * @return the collection of threads
    */
public final Collection<Thread> getQueuedThreads() {
    ArrayList<Thread> list = new ArrayList<>();
    for (Node p = tail; p != null; p = p.prev) {
        Thread t = p.waiter;
        if (t != null)
            list.add(t);
    }
    return list;
}

{% endhighlight %}


##### 获取同步队列中试图加独占锁的线程

{% highlight java linenos %}
/**
    * Returns a collection containing threads that may be waiting to
    * acquire in exclusive mode. This has the same properties
    * as {@link #getQueuedThreads} except that it only returns
    * those threads waiting due to an exclusive acquire.
    *
    * @return the collection of threads
    */
public final Collection<Thread> getExclusiveQueuedThreads() {
    ArrayList<Thread> list = new ArrayList<>();
    for (Node p = tail; p != null; p = p.prev) {
        if (!(p instanceof SharedNode)) {
            Thread t = p.waiter;
            if (t != null)
                list.add(t);
        }
    }
    return list;
}
{% endhighlight %}


##### 获取同步队列中试图加共享锁的线程

{% highlight java linenos %}
/**
    * Returns a collection containing threads that may be waiting to
    * acquire in shared mode. This has the same properties
    * as {@link #getQueuedThreads} except that it only returns
    * those threads waiting due to a shared acquire.
    *
    * @return the collection of threads
    */
public final Collection<Thread> getSharedQueuedThreads() {
    ArrayList<Thread> list = new ArrayList<>();
    for (Node p = tail; p != null; p = p.prev) {
        if (p instanceof SharedNode) {
            Thread t = p.waiter;
            if (t != null)
                list.add(t);
        }
    }
    return list;
}

{% endhighlight %}


##### 判断指定的条件对象是否由当前abs对象拥有

{% highlight java linenos %}
// Instrumentation methods for conditions

/**
    * Queries whether the given ConditionObject
    * uses this synchronizer as its lock.
    *
    * @param condition the condition
    * @return {@code true} if owned
    * @throws NullPointerException if the condition is null
    */
public final boolean owns(ConditionObject condition) {
    return condition.isOwnedBy(this);
}

{% endhighlight %}


##### 判断指定条件对象中是否有节点在排队

{% highlight java linenos %}
/**
    * Queries whether any threads are waiting on the given condition
    * associated with this synchronizer. Note that because timeouts
    * and interrupts may occur at any time, a {@code true} return
    * does not guarantee that a future {@code signal} will awaken
    * any threads.  This method is designed primarily for use in
    * monitoring of the system state.
    *
    * @param condition the condition
    * @return {@code true} if there are any waiting threads
    * @throws IllegalMonitorStateException if exclusive synchronization
    *         is not held
    * @throws IllegalArgumentException if the given condition is
    *         not associated with this synchronizer
    * @throws NullPointerException if the condition is null
    */
public final boolean hasWaiters(ConditionObject condition) {
    if (!owns(condition))
        throw new IllegalArgumentException("Not owner");
    return condition.hasWaiters();
}

{% endhighlight %}

##### 获取指定条件队列的长度（排队节点数）

{% highlight java linenos %}
/**
    * Returns an estimate of the number of threads waiting on the
    * given condition associated with this synchronizer. Note that
    * because timeouts and interrupts may occur at any time, the
    * estimate serves only as an upper bound on the actual number of
    * waiters.  This method is designed for use in monitoring system
    * state, not for synchronization control.
    *
    * @param condition the condition
    * @return the estimated number of waiting threads
    * @throws IllegalMonitorStateException if exclusive synchronization
    *         is not held
    * @throws IllegalArgumentException if the given condition is
    *         not associated with this synchronizer
    * @throws NullPointerException if the condition is null
    */
public final int getWaitQueueLength(ConditionObject condition) {
    if (!owns(condition))
        throw new IllegalArgumentException("Not owner");
    return condition.getWaitQueueLength();
}
{% endhighlight %}


##### 获取指定条件队列中排队的线程

{% highlight java linenos %}

/**
    * Returns a collection containing those threads that may be
    * waiting on the given condition associated with this
    * synchronizer.  Because the actual set of threads may change
    * dynamically while constructing this result, the returned
    * collection is only a best-effort estimate. The elements of the
    * returned collection are in no particular order.
    *
    * @param condition the condition
    * @return the collection of threads
    * @throws IllegalMonitorStateException if exclusive synchronization
    *         is not held
    * @throws IllegalArgumentException if the given condition is
    *         not associated with this synchronizer
    * @throws NullPointerException if the condition is null
    */
public final Collection<Thread> getWaitingThreads(ConditionObject condition) {
    if (!owns(condition))
        throw new IllegalArgumentException("Not owner");
    return condition.getWaitingThreads();
}
{% endhighlight %}

#### ConditionObject

##### ConditionObject 定义

{% highlight java linenos %}
public class ConditionObject implements Condition, java.io.Serializable
{% endhighlight %}


##### ConditionObject doSignal

通知当前条件队列中的某个节点（或者包含后继节点）不用继续留在条件队列了，可以去同步队列的队尾排着，等待抢锁的机会了。

{% highlight java linenos %}
private void doSignal(ConditionNode first, boolean all) {
    while (first != null) {
        ConditionNode next = first.nextWaiter;
        if ((firstWaiter = next) == null)
            lastWaiter = null;
        if ((first.getAndUnsetStatus(COND) & COND) != 0) {  //取消掉COND标记，如果原来带有COND标记，则去同步队列后面排队
            enqueue(first);
            if (!all)
                break;
        }
        first = next;
    }
}
{% endhighlight %}


##### ConditionObject signal

通知当前条件队列中的第一个节点不用继续留在条件队列了，可以去同步队列的队尾排着，等待抢锁的机会了。

{% highlight java linenos %}
public final void signal() {
    ConditionNode first = firstWaiter;
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    if (first != null)
        doSignal(first, false);
}
{% endhighlight %}

##### ConditionObject signalAll

通知当前条件队列中的所有节点不用继续留在条件队列了，可以去同步队列的队尾排着，等待抢锁的机会了。

{% highlight java linenos %}
/**
    * Moves all threads from the wait queue for this condition to
    * the wait queue for the owning lock.
    *
    * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
    *         returns {@code false}
    */
public final void signalAll() {
    ConditionNode first = firstWaiter;
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    if (first != null)
        doSignal(first, true);
}
{% endhighlight %}


##### ConditionObject enableWait

当前线程需要等待某个特殊的条件了，需要释放掉它占有的锁，否则，其它的线程无法运行，当前线程等待的条件可能永远无法满足。

{% highlight java linenos %}
// Waiting methods
/**
    * Adds node to condition list and releases lock.
    *
    * @param node the node
    * @return savedState to reacquire after wait
    */
private int enableWait(ConditionNode node) {
    if (isHeldExclusively()) {
        node.waiter = Thread.currentThread();
        node.setStatusRelaxed(COND | WAITING);
        ConditionNode last = lastWaiter;
        if (last == null)
            firstWaiter = node;
        else
            last.nextWaiter = node;
        lastWaiter = node;
        int savedState = getState();
        if (release(savedState))
            return savedState;
    }
    node.status = CANCELLED; // lock not held or inconsistent
    throw new IllegalMonitorStateException();
}
{% endhighlight %}


##### ConditionObject canReacquire

当前节点是否在同步队列中，在的话就不能重新进入同步队列中争抢锁。

{% highlight java linenos %}
/**
    * Returns true if a node that was initially placed on a condition
    * queue is now ready to reacquire on sync queue.
    * @param node the node
    * @return true if is reacquiring
    */
private boolean canReacquire(ConditionNode node) {
    // check links, not status to avoid enqueue race
    return node != null && node.prev != null && isEnqueued(node);
}
{% endhighlight %}


##### ConditionObject unlinkCancelledWaiters

从条件队列中删除自指定节点起的所有已经取消的节点。

{% highlight java linenos %}
/**
    * Unlinks the given node and other non-waiting nodes from
    * condition queue unless already unlinked.
    */
private void unlinkCancelledWaiters(ConditionNode node) {
    if (node == null || node.nextWaiter != null || node == lastWaiter) {
        ConditionNode w = firstWaiter, trail = null;
        while (w != null) {
            ConditionNode next = w.nextWaiter;
            if ((w.status & COND) == 0) {
                w.nextWaiter = null;
                if (trail == null)
                    firstWaiter = next;
                else
                    trail.nextWaiter = next;
                if (next == null)
                    lastWaiter = trail;
            } else
                trail = w;
            w = next;
        }
    }
}
{% endhighlight %}


##### ConditionObject awaitUninterruptibly

等待条件。

{% highlight java linenos %}

/**
    * Implements uninterruptible condition wait.
    * <ol>
    * <li>Save lock state returned by {@link #getState}.
    * <li>Invoke {@link #release} with saved state as argument,
    *     throwing IllegalMonitorStateException if it fails.
    * <li>Block until signalled.
    * <li>Reacquire by invoking specialized version of
    *     {@link #acquire} with saved state as argument.
    * </ol>
    */
public final void awaitUninterruptibly() {
    ConditionNode node = new ConditionNode();
    int savedState = enableWait(node);             //走到这里，说明当前线程已经拥有锁了，那就必须要释放掉，否则其它线程就卡主了，当前线程需要的条件就没谁去创造了
    LockSupport.setCurrentBlocker(this); // for back-compatibility
    boolean interrupted = false;
    while (!canReacquire(node)) {     //当前节点没有转移到同步队列。doSignal会调用enqueue将某个节点转移到同步队列中，并且将其唤醒
        if (Thread.interrupted())
            interrupted = true;
        else if ((node.status & COND) != 0) {      //节点设置了COND标记
            try {
                ForkJoinPool.managedBlock(node);    //休眠，等待signal/signalAll唤醒
            } catch (InterruptedException ie) {
                interrupted = true;
            }
        } else
            Thread.onSpinWait();    // awoke while enqueuing
    }
    LockSupport.setCurrentBlocker(null);
    node.clearStatus();           //节点状态设置为初始化状态
    acquire(node, savedState, false, false, false, 0L);        //去同步队列中抢锁
    if (interrupted)
        Thread.currentThread().interrupt();
}

{% endhighlight %}


##### ConditionObject await

{% highlight java linenos %}
/**
    * Implements interruptible condition wait.
    * <ol>
    * <li>If current thread is interrupted, throw InterruptedException.
    * <li>Save lock state returned by {@link #getState}.
    * <li>Invoke {@link #release} with saved state as argument,
    *     throwing IllegalMonitorStateException if it fails.
    * <li>Block until signalled or interrupted.
    * <li>Reacquire by invoking specialized version of
    *     {@link #acquire} with saved state as argument.
    * <li>If interrupted while blocked in step 4, throw InterruptedException.
    * </ol>
    */
public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    ConditionNode node = new ConditionNode();
    int savedState = enableWait(node);
    LockSupport.setCurrentBlocker(this); // for back-compatibility
    boolean interrupted = false, cancelled = false;
    while (!canReacquire(node)) {
        if (interrupted |= Thread.interrupted()) {
            if (cancelled = (node.getAndUnsetStatus(COND) & COND) != 0)
                break;              // else interrupted after signal
        } else if ((node.status & COND) != 0) {
            try {
                ForkJoinPool.managedBlock(node);
            } catch (InterruptedException ie) {
                interrupted = true;
            }
        } else
            Thread.onSpinWait();    // awoke while enqueuing
    }
    LockSupport.setCurrentBlocker(null);
    node.clearStatus();
    acquire(node, savedState, false, false, false, 0L);
    if (interrupted) {
        if (cancelled) {
            unlinkCancelledWaiters(node);
            throw new InterruptedException();
        }
        Thread.currentThread().interrupt();
    }
}

{% endhighlight %}


##### ConditionObject awaitNanos

{% highlight java linenos %}
/**
    * Implements timed condition wait.
    * <ol>
    * <li>If current thread is interrupted, throw InterruptedException.
    * <li>Save lock state returned by {@link #getState}.
    * <li>Invoke {@link #release} with saved state as argument,
    *     throwing IllegalMonitorStateException if it fails.
    * <li>Block until signalled, interrupted, or timed out.
    * <li>Reacquire by invoking specialized version of
    *     {@link #acquire} with saved state as argument.
    * <li>If interrupted while blocked in step 4, throw InterruptedException.
    * </ol>
    */
public final long awaitNanos(long nanosTimeout)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    ConditionNode node = new ConditionNode();
    int savedState = enableWait(node);
    long nanos = (nanosTimeout < 0L) ? 0L : nanosTimeout;
    long deadline = System.nanoTime() + nanos;
    boolean cancelled = false, interrupted = false;
    while (!canReacquire(node)) {
        if ((interrupted |= Thread.interrupted()) ||
            (nanos = deadline - System.nanoTime()) <= 0L) {
            if (cancelled = (node.getAndUnsetStatus(COND) & COND) != 0)
                break;
        } else
            LockSupport.parkNanos(this, nanos);
    }
    node.clearStatus();
    acquire(node, savedState, false, false, false, 0L);
    if (cancelled) {
        unlinkCancelledWaiters(node);
        if (interrupted)
            throw new InterruptedException();
    } else if (interrupted)
        Thread.currentThread().interrupt();
    long remaining = deadline - System.nanoTime(); // avoid overflow
    return (remaining <= nanosTimeout) ? remaining : Long.MIN_VALUE;
}

{% endhighlight %}


##### ConditionObject awaitUntil

{% highlight java linenos %}
/**
    * Implements absolute timed condition wait.
    * <ol>
    * <li>If current thread is interrupted, throw InterruptedException.
    * <li>Save lock state returned by {@link #getState}.
    * <li>Invoke {@link #release} with saved state as argument,
    *     throwing IllegalMonitorStateException if it fails.
    * <li>Block until signalled, interrupted, or timed out.
    * <li>Reacquire by invoking specialized version of
    *     {@link #acquire} with saved state as argument.
    * <li>If interrupted while blocked in step 4, throw InterruptedException.
    * <li>If timed out while blocked in step 4, return false, else true.
    * </ol>
    */
public final boolean awaitUntil(Date deadline)
        throws InterruptedException {
    long abstime = deadline.getTime();
    if (Thread.interrupted())
        throw new InterruptedException();
    ConditionNode node = new ConditionNode();
    int savedState = enableWait(node);
    boolean cancelled = false, interrupted = false;
    while (!canReacquire(node)) {
        if ((interrupted |= Thread.interrupted()) ||
            System.currentTimeMillis() >= abstime) {
            if (cancelled = (node.getAndUnsetStatus(COND) & COND) != 0)
                break;
        } else
            LockSupport.parkUntil(this, abstime);
    }
    node.clearStatus();
    acquire(node, savedState, false, false, false, 0L);
    if (cancelled) {
        unlinkCancelledWaiters(node);
        if (interrupted)
            throw new InterruptedException();
    } else if (interrupted)
        Thread.currentThread().interrupt();
    return !cancelled;
}

{% endhighlight %}


##### ConditionObject await

{% highlight java linenos %}

/**
    * Implements timed condition wait.
    * <ol>
    * <li>If current thread is interrupted, throw InterruptedException.
    * <li>Save lock state returned by {@link #getState}.
    * <li>Invoke {@link #release} with saved state as argument,
    *     throwing IllegalMonitorStateException if it fails.
    * <li>Block until signalled, interrupted, or timed out.
    * <li>Reacquire by invoking specialized version of
    *     {@link #acquire} with saved state as argument.
    * <li>If interrupted while blocked in step 4, throw InterruptedException.
    * <li>If timed out while blocked in step 4, return false, else true.
    * </ol>
    */
public final boolean await(long time, TimeUnit unit)
        throws InterruptedException {
    long nanosTimeout = unit.toNanos(time);
    if (Thread.interrupted())
        throw new InterruptedException();
    ConditionNode node = new ConditionNode();
    int savedState = enableWait(node);
    long nanos = (nanosTimeout < 0L) ? 0L : nanosTimeout;
    long deadline = System.nanoTime() + nanos;
    boolean cancelled = false, interrupted = false;
    while (!canReacquire(node)) {
        if ((interrupted |= Thread.interrupted()) ||
            (nanos = deadline - System.nanoTime()) <= 0L) {
            if (cancelled = (node.getAndUnsetStatus(COND) & COND) != 0)
                break;
        } else
            LockSupport.parkNanos(this, nanos);
    }
    node.clearStatus();
    acquire(node, savedState, false, false, false, 0L);
    if (cancelled) {
        unlinkCancelledWaiters(node);
        if (interrupted)
            throw new InterruptedException();
    } else if (interrupted)
        Thread.currentThread().interrupt();
    return !cancelled;
}

{% endhighlight %}


##### ConditionObject isOwnedBy

{% highlight java linenos %}

//  support for instrumentation

/**
    * Returns true if this condition was created by the given
    * synchronization object.
    *
    * @return {@code true} if owned
    */
final boolean isOwnedBy(AbstractQueuedSynchronizer sync) {
    return sync == AbstractQueuedSynchronizer.this;
}
{% endhighlight %}


##### ConditionObject hasWaiters

{% highlight java linenos %}

/**
    * Queries whether any threads are waiting on this condition.
    * Implements {@link AbstractQueuedSynchronizer#hasWaiters(ConditionObject)}.
    *
    * @return {@code true} if there are any waiting threads
    * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
    *         returns {@code false}
    */
protected final boolean hasWaiters() {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {
        if ((w.status & COND) != 0)
            return true;
    }
    return false;
}
{% endhighlight %}


##### ConditionObject getWaitQueueLength

{% highlight java linenos %}

/**
    * Returns an estimate of the number of threads waiting on
    * this condition.
    * Implements {@link AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject)}.
    *
    * @return the estimated number of waiting threads
    * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
    *         returns {@code false}
    */
protected final int getWaitQueueLength() {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    int n = 0;
    for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {
        if ((w.status & COND) != 0)
            ++n;
    }
    return n;
}
{% endhighlight %}


##### ConditionObject getWaitingThreads

{% highlight java linenos %}

/**
    * Returns a collection containing those threads that may be
    * waiting on this Condition.
    * Implements {@link AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject)}.
    *
    * @return the collection of threads
    * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
    *         returns {@code false}
    */
protected final Collection<Thread> getWaitingThreads() {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    ArrayList<Thread> list = new ArrayList<>();
    for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {
        if ((w.status & COND) != 0) {
            Thread t = w.waiter;
            if (t != null)
                list.add(t);
        }
    }
    return list;
}

{% endhighlight %}
