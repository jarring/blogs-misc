---
layout: article
title: java StampedLock源码深入解析
date: 2020-06-11 07:35:24 +0800
categories: java
tags: jdk14 源码
---
本文尝试详细阐述一下jdk14的[StampedLock](http://hg.openjdk.java.net/jdk/jdk/file/jdk-14-ga/src/java.base/share/classes/java/util/concurrent/locks/StampedLock.java){:target="_blank"}源码。
[jdk8](http://hg.openjdk.java.net/jdk/jdk/file/jdk8-b100/jdk/src/share/classes/java/util/concurrent/locks/StampedLock.java){:target="_blank"}


此类提供了读锁、写锁、乐观读锁，这三种锁可以互相转换。


此类代码不多，但非常晦涩难懂，因为有大量的自旋锁操作。

##### 定义

这个类居然还支持序列化。
{% highlight java linenos %}
public class StampedLock implements java.io.Serializable
{% endhighlight %}


##### 构造方法

初始化。

{% highlight java linenos %}
public StampedLock() {
    state = ORIGIN;
}
{% endhighlight %}

##### 状态常量

{% highlight java linenos %}
private static final int LG_READERS = 7; // 127 readers
private static final long RUNIT = 1L;
private static final long WBIT = 1L << LG_READERS;                   // 1 << 7，                 1000_0000 写标志位，只许一个写
private static final long RBITS = WBIT - 1L;                         // 127，                    0111_1111 读标志位，允许多个读
private static final long RFULL = RBITS - 1L;                        // 126，                    0111_1110 读的数量，超过就溢出到readerOverflow
private static final long ABITS = RBITS | WBIT;                      // 255，                    1111_1111 读、写的标志位
private static final long SBITS = ~RBITS; // note overlap with ABITS //-128，             1...11 1000_0000
private static final long RSAFE = ~(3L << (LG_READERS - 1));         //-193，^1100_0000   1...11 0011_1111
private static final long ORIGIN = WBIT << 1;                        // 1 << 0，          0...01 0000_0000
{% endhighlight %}


##### 内部变量

注意volatile变量。head、tail变量与AQS的非常类似。

{% highlight java linenos %}
/** Head of CLH queue */
private transient volatile Node head; 
/** Tail (last) of CLH queue */
private transient volatile Node tail;

// views
transient ReadLockView readLockView;
transient WriteLockView writeLockView;
transient ReadWriteLockView readWriteLockView;

/** Lock sequence/state */
private transient volatile long state;
/** extra reader count when state read count saturated */
private transient int readerOverflow;
{% endhighlight %}


##### StampedLock Node定义

注意，前置节点、后置节点、status变量都是volatile类型。与AQS的非常类似。

{% highlight java linenos %}
/** CLH nodes */
abstract static class Node {
    volatile Node prev;       // initially attached via casTail
    volatile Node next;       // visibly nonnull when signallable
    Thread waiter;            // visibly nonnull when enqueued
    volatile int status;      // written by owner, atomic bit ops by others
}
{% endhighlight %}

##### StampedLock 读写节点定义

写节点在主队列上排队，但读节点在主队列的基础上，又拉了一个分支队列，专门用于读节点排队。

{% highlight java linenos %}
static final class WriterNode extends Node { // node for writers
}

static final class ReaderNode extends Node { // node for readers
    volatile ReaderNode cowaiters;           // list of linked readers
}
{% endhighlight %}


##### tryAcquireWrite

尝试加写锁。如果没有加过任何锁，则加锁成功。

{% highlight java linenos %}
private long tryAcquireWrite() {
    long s, nextState;
    if (((s = state) & ABITS /*1111_1111*/) == 0L && casState(s, nextState = s | WBIT /*1000_0000*/)) {
        U.storeStoreFence();
        return nextState;
    }
    return 0L;
}
{% endhighlight %}


##### tryAcquireRead

尝试加读锁。如果没有加过写锁，则不断循环至加锁成功，真的是非常执着。

{% highlight java linenos %}
private long tryAcquireRead() {
    for (long s, m, nextState;;) {
        if ((m = (s = state) & ABITS /*1111_1111*/) < RFULL /*0111_1110*/) {        //读锁数量没有溢出
            if (casState(s, nextState = s + RUNIT))
                return nextState;
        }
        else if (m == WBIT /*1000_0000*/) // 已经加了写锁了，加读锁失败
            return 0L;
        else if ((nextState = tryIncReaderOverflow(s)) != 0L)      //读锁数量溢出到变量readerOverflow
            return nextState;
    }
}
{% endhighlight %}


##### unlockWriteState 释放写锁状态

执行到这个方法的时候，已经表明当前线程拥有了写锁，第8位已经为1了。

加上WBIT，第8位变为0，且锁的版本也跟着变了。如果溢出了归0了，则从ORIGIN开始。

{% highlight java linenos %}
/**
    * Returns an unlocked state, incrementing the version and
    * avoiding special failure value 0L.
    *
    * @param s a write-locked state (or stamp)
    */
private static long unlockWriteState(long s) {  
    return ((s += WBIT /*1000_0000*/) == 0L) ? ORIGIN : s;
}

{% endhighlight %}


##### releaseWrite 释放写锁且唤醒后继线程

{% highlight java linenos %}
private long releaseWrite(long s) {
    long nextState = state = unlockWriteState(s);
    signalNext(head);
    return nextState;
}

{% endhighlight %}


##### writeLock 加写锁

{% highlight java linenos %}
/**
    * Exclusively acquires the lock, blocking if necessary
    * until available.
    *
    * @return a write stamp that can be used to unlock or convert mode
    */
@ReservedStackAccess
public long writeLock() {
    // try unconditional CAS confirming weak read  
    long s = U.getLongOpaque(this, STATE) & ~ABITS /*1111_1111*/ /*1...1 0000_0000*/, nextState;
    if (casState(s, nextState = s | WBIT /*1000_0000*/)) { //如果state的低8位为0，则表明没有加任何锁
        U.storeStoreFence();
        return nextState; //加锁成功
    }
    return acquireWrite(false, false, 0L); //去队尾排队等待锁
}

{% endhighlight %}

##### tryWriteLock

{% highlight java linenos %}
/**
    * Exclusively acquires the lock if it is immediately available.
    *
    * @return a write stamp that can be used to unlock or convert mode,
    * or zero if the lock is not available
    */
public long tryWriteLock() {
    return tryAcquireWrite();
}

{% endhighlight %}


##### tryWriteLock 超时版的加写锁

{% highlight java linenos %}
/**
    * Exclusively acquires the lock if it is available within the
    * given time and the current thread has not been interrupted.
    * Behavior under timeout and interruption matches that specified
    * for method {@link Lock#tryLock(long,TimeUnit)}.
    *
    * @param time the maximum time to wait for the lock
    * @param unit the time unit of the {@code time} argument
    * @return a write stamp that can be used to unlock or convert mode,
    * or zero if the lock is not available
    * @throws InterruptedException if the current thread is interrupted
    * before acquiring the lock
    */
public long tryWriteLock(long time, TimeUnit unit)
    throws InterruptedException {
    long nanos = unit.toNanos(time);
    if (!Thread.interrupted()) {
        long nextState;
        if ((nextState = tryAcquireWrite()) != 0L)
            return nextState;
        if (nanos <= 0L)
            return 0L;
        nextState = acquireWrite(true, true, System.nanoTime() + nanos);
        if (nextState != INTERRUPTED)
            return nextState;
    }
    throw new InterruptedException();
}

{% endhighlight %}

##### writeLockInterruptibly 响应中断版的加写锁

{% highlight java linenos %}
/**
    * Exclusively acquires the lock, blocking if necessary
    * until available or the current thread is interrupted.
    * Behavior under interruption matches that specified
    * for method {@link Lock#lockInterruptibly()}.
    *
    * @return a write stamp that can be used to unlock or convert mode
    * @throws InterruptedException if the current thread is interrupted
    * before acquiring the lock
    */
public long writeLockInterruptibly() throws InterruptedException {
    long nextState;
    if (!Thread.interrupted() &&
        ((nextState = tryAcquireWrite()) != 0L ||
            (nextState = acquireWrite(true, false, 0L)) != INTERRUPTED))
        return nextState;
    throw new InterruptedException();
}

{% endhighlight %}


##### readLock 加读锁

{% highlight java linenos %}
/**
    * Non-exclusively acquires the lock, blocking if necessary
    * until available.
    *
    * @return a read stamp that can be used to unlock or convert mode
    */
@ReservedStackAccess
public long readLock() {
    // unconditionally optimistically try non-overflow case once
    long s = U.getLongOpaque(this, STATE) & RSAFE /*1...11 0011_1111*/, nextState;
    if (casState(s, nextState = s + RUNIT))     //如果 state & RSAFE == state，说明没加过读写锁，加锁成功，更新读锁数量
        return nextState;
    else
        return acquireRead(false, false, 0L);    //排队，等待抢锁读机会
}

{% endhighlight %}


##### tryReadLock 加读锁


{% highlight java linenos %}
/**
    * Non-exclusively acquires the lock if it is immediately available.
    *
    * @return a read stamp that can be used to unlock or convert mode,
    * or zero if the lock is not available
    */
public long tryReadLock() {
    return tryAcquireRead();
}

{% endhighlight %}

##### tryReadLock 加读锁，超时版

{% highlight java linenos %}
/**
    * Non-exclusively acquires the lock if it is available within the
    * given time and the current thread has not been interrupted.
    * Behavior under timeout and interruption matches that specified
    * for method {@link Lock#tryLock(long,TimeUnit)}.
    *
    * @param time the maximum time to wait for the lock
    * @param unit the time unit of the {@code time} argument
    * @return a read stamp that can be used to unlock or convert mode,
    * or zero if the lock is not available
    * @throws InterruptedException if the current thread is interrupted
    * before acquiring the lock
    */
public long tryReadLock(long time, TimeUnit unit)
    throws InterruptedException {
    long nanos = unit.toNanos(time);
    if (!Thread.interrupted()) {
        long nextState;
        if (tail == head && (nextState = tryAcquireRead()) != 0L)
            return nextState;
        if (nanos <= 0L)
            return 0L;
        nextState = acquireRead(true, true, System.nanoTime() + nanos);
        if (nextState != INTERRUPTED)
            return nextState;
    }
    throw new InterruptedException();
}

{% endhighlight %}

##### tryReadLock 加读锁，响应中断

{% highlight java linenos %}
/**
    * Non-exclusively acquires the lock, blocking if necessary
    * until available or the current thread is interrupted.
    * Behavior under interruption matches that specified
    * for method {@link Lock#lockInterruptibly()}.
    *
    * @return a read stamp that can be used to unlock or convert mode
    * @throws InterruptedException if the current thread is interrupted
    * before acquiring the lock
    */
public long readLockInterruptibly() throws InterruptedException {
    long nextState;
    if (!Thread.interrupted() &&
        ((nextState = tryAcquireRead()) != 0L ||
            (nextState = acquireRead(true, false, 0L)) != INTERRUPTED))
        return nextState;
    throw new InterruptedException();
}

{% endhighlight %}

##### tryOptimisticRead 加乐观读锁

没有加过写锁，那么就可以成功加上乐观锁。乐观锁并没有设置任何标志位。只要当前没有加写锁，就认为加乐观锁成功了。

{% highlight java linenos %}
/**
    * Returns a stamp that can later be validated, or zero
    * if exclusively locked.
    *
    * @return a valid optimistic read stamp, or zero if exclusively locked
    */
public long tryOptimisticRead() {
    long s;
    return (((s = state) & WBIT /*1000_0000*/) == 0L) ? (s & SBITS /*1...11 1000_0000*/) : 0L;
}

{% endhighlight %}

##### validate 验证是否加过写锁

第8位及更高位变了就意味加了写锁，加写锁意味着数据被修改了。

{% highlight java linenos %}
/**
    * Returns true if the lock has not been exclusively acquired
    * since issuance of the given stamp. Always returns false if the
    * stamp is zero. Always returns true if the stamp represents a
    * currently held lock. Invoking this method with a value not
    * obtained from {@link #tryOptimisticRead} or a locking method
    * for this lock has no defined effect or result.
    *
    * @param stamp a stamp
    * @return {@code true} if the lock has not been exclusively acquired
    * since issuance of the given stamp; else false
    */
public boolean validate(long stamp) {
    U.loadFence();         //第8位及更高位没有变化
    return (stamp & SBITS /*1...11 1000_0000*/) == (state & SBITS /*1...11 1000_0000*/);
}

{% endhighlight %}

##### unstampedUnlockWrite 释放写锁且不验证stamp

{% highlight java linenos %}

// Unlock methods without stamp argument checks for view classes.
// Needed because view-class lock methods throw away stamps.

final void unstampedUnlockWrite() {
    long s;
    if (((s = state) & WBIT /*1000_0000*/) == 0L)
        throw new IllegalMonitorStateException();
    releaseWrite(s);
}
{% endhighlight %}


##### unlockWrite 释放写锁

{% highlight java linenos %}
/**
    * If the lock state matches the given stamp, releases the
    * exclusive lock.
    *
    * @param stamp a stamp returned by a write-lock operation
    * @throws IllegalMonitorStateException if the stamp does
    * not match the current state of this lock
    */
@ReservedStackAccess
public void unlockWrite(long stamp) {
    if (state != stamp || (stamp & WBIT /*1000_0000*/) == 0L)  //加过其它锁，或者没有加过写锁
        throw new IllegalMonitorStateException();
    releaseWrite(stamp);
}

{% endhighlight %}


##### unstampedUnlockRead 释放读锁但不验证stamp

{% highlight java linenos %}

final void unstampedUnlockRead() {
    long s, m;
    while ((m = (s = state) & RBITS /*0111_1111*/) > 0L) {
        if (m < RFULL /*0111_1110*/) {
            if (casState(s, s - RUNIT)) {
                if (m == RUNIT)
                    signalNext(head);
                return;
            }
        }
        else if (tryDecReaderOverflow(s) != 0L)
            return;
    }
    throw new IllegalMonitorStateException();
}
{% endhighlight %}

##### unlockRead 释放读锁

没有加过写锁，且加过了读锁，就释放一次读锁。

{% highlight java linenos %}
/**
    * If the lock state matches the given stamp, releases the
    * non-exclusive lock.
    *
    * @param stamp a stamp returned by a read-lock operation
    * @throws IllegalMonitorStateException if the stamp does
    * not match the current state of this lock
    */
@ReservedStackAccess
public void unlockRead(long stamp) {
    long s, m;
    if ((stamp & RBITS /*0111_1111*/) != 0L) {
        while (((s = state) & SBITS /*1...11 1000_0000*/) == (stamp & SBITS /*1...11 1000_0000*/) && //确实加过读锁且没加过写锁
                ((m = s & RBITS /*0111_1111*/) != 0L)) { //并且读锁还没释放完
            if (m < RFULL /*0111_1110*/) { //没溢出过
                if (casState(s, s - RUNIT)) {
                    if (m == RUNIT)   //唯一的一个写锁被释放了，该唤醒后继节点了
                        signalNext(head);
                    return;
                }
            }
            else if (tryDecReaderOverflow(s) != 0L)  //溢出到readerOverflow了
                return;
        }
    }
    throw new IllegalMonitorStateException();
}

{% endhighlight %}

##### unlock 释放锁

自动判断释放读锁还是写锁。

{% highlight java linenos %}
/**
    * If the lock state matches the given stamp, releases the
    * corresponding mode of the lock.
    *
    * @param stamp a stamp returned by a lock operation
    * @throws IllegalMonitorStateException if the stamp does
    * not match the current state of this lock
    */
public void unlock(long stamp) {
    if ((stamp & WBIT /*1000_0000*/) != 0L)
        unlockWrite(stamp);
    else
        unlockRead(stamp);
}

{% endhighlight %}

##### tryConvertToWriteLock 试图将当前锁转化为写锁

{% highlight java linenos %}
/**
    * If the lock state matches the given stamp, atomically performs one of
    * the following actions. If the stamp represents holding a write
    * lock, returns it.  Or, if a read lock, if the write lock is
    * available, releases the read lock and returns a write stamp.
    * Or, if an optimistic read, returns a write stamp only if
    * immediately available. This method returns zero in all other
    * cases.
    *
    * @param stamp a stamp
    * @return a valid write stamp, or zero on failure
    */
public long tryConvertToWriteLock(long stamp) {
    long a = stamp & ABITS /*1111_1111*/, m, s, nextState;     //a = 0表明此刻没有锁，否则表示有锁
    while (((s = state) & SBITS /*1...11 1000_0000*/) == (stamp & SBITS /*1...11 1000_0000*/)) { //第8位及更高位没变化
        if ((m = s & ABITS /*1111_1111*/) == 0L) { //读写标志没被设置，表明当前没有加锁
            if (a != 0L) //进入函数的时候加了锁
                break;
            if (casState(s, nextState = s | WBIT /*1000_0000*/)) { //没有加读写锁，加上
                U.storeStoreFence();
                return nextState;
            }
        } else if (m == WBIT /*1000_0000*/) {    //加了写锁
            if (a != m)      //进入函数的时候加的是读锁
                break;
            return stamp;
        } else if (m == RUNIT && a != 0L) { //只有一个读锁了，释放掉，并加上写锁
            if (casState(s, nextState = s - RUNIT + WBIT /*1000_0000*/))
                return nextState;
        } else
            break;
    }
    return 0L;
}

{% endhighlight %}


##### tryConvertToReadLock 试图将当前锁转化为读锁

{% highlight java linenos %}
/**
    * If the lock state matches the given stamp, atomically performs one of
    * the following actions. If the stamp represents holding a write
    * lock, releases it and obtains a read lock.  Or, if a read lock,
    * returns it. Or, if an optimistic read, acquires a read lock and
    * returns a read stamp only if immediately available. This method
    * returns zero in all other cases.
    *
    * @param stamp a stamp
    * @return a valid read stamp, or zero on failure
    */
public long tryConvertToReadLock(long stamp) {
    long a, s, nextState;
    while (((s = state) & SBITS /*1...11 1000_0000*/) == (stamp & SBITS /*1...11 1000_0000*/)) {
        if ((a = stamp & ABITS /*1111_1111*/) >= WBIT /*1000_0000*/) {
            if (s != stamp) // write stamp
                break;
            nextState = state = unlockWriteState(s) + RUNIT;
            signalNext(head);
            return nextState;
        } else if (a == 0L) { // optimistic read stamp
            if ((s & ABITS /*1111_1111*/) < RFULL /*0111_1110*/) {
                if (casState(s, nextState = s + RUNIT))
                    return nextState;
            } else if ((nextState = tryIncReaderOverflow(s)) != 0L)
                return nextState;
        } else { // already a read stamp
            if ((s & ABITS /*1111_1111*/) == 0L)
                break;
            return stamp;
        }
    }
    return 0L;
}

{% endhighlight %}


##### tryConvertToReadLock 试图将当前锁转化为乐观读锁


{% highlight java linenos %}
/**
    * If the lock state matches the given stamp then, atomically, if the stamp
    * represents holding a lock, releases it and returns an
    * observation stamp.  Or, if an optimistic read, returns it if
    * validated. This method returns zero in all other cases, and so
    * may be useful as a form of "tryUnlock".
    *
    * @param stamp a stamp
    * @return a valid optimistic read stamp, or zero on failure
    */
public long tryConvertToOptimisticRead(long stamp) {
    long a, m, s, nextState;
    U.loadFence();
    while (((s = state) & SBITS /*1...11 1000_0000*/) == (stamp & SBITS /*1...11 1000_0000*/)) {
        if ((a = stamp & ABITS /*1111_1111*/) >= WBIT /*1000_0000*/) {
            if (s != stamp)   // write stamp
                break;
            return releaseWrite(s);
        } else if (a == 0L) { // already an optimistic read stamp
            return stamp;
        } else if ((m = s & ABITS /*1111_1111*/) == 0L) { // invalid read stamp
            break;
        } else if (m < RFULL /*0111_1110*/) {
            if (casState(s, nextState = s - RUNIT)) {
                if (m == RUNIT)
                    signalNext(head);
                return nextState & SBITS /*1...11 1000_0000*/;
            }
        } else if ((nextState = tryDecReaderOverflow(s)) != 0L)
            return nextState & SBITS /*1...11 1000_0000*/;
    }
    return 0L;
}

{% endhighlight %}


##### tryUnlockWrite 尝试释放写锁


{% highlight java linenos %}
/**
    * Releases the write lock if it is held, without requiring a
    * stamp value. This method may be useful for recovery after
    * errors.
    *
    * @return {@code true} if the lock was held, else false
    */
@ReservedStackAccess
public boolean tryUnlockWrite() {
    long s;
    if (((s = state) & WBIT /*1000_0000*/) != 0L) {
        releaseWrite(s);
        return true;
    }
    return false;
}
{% endhighlight %}


##### tryUnlockRead 尝试释放读锁

{% highlight java linenos %}

/**
    * Releases one hold of the read lock if it is held, without
    * requiring a stamp value. This method may be useful for recovery
    * after errors.
    *
    * @return {@code true} if the read lock was held, else false
    */
@ReservedStackAccess
public boolean tryUnlockRead() {
    long s, m;
    while ((m = (s = state) & ABITS /*1111_1111*/) != 0L && m < WBIT /*1000_0000*/) {
        if (m < RFULL /*0111_1110*/) {
            if (casState(s, s - RUNIT)) {
                if (m == RUNIT)
                    signalNext(head);
                return true;
            }
        }
        else if (tryDecReaderOverflow(s) != 0L)
            return true;
    }
    return false;
}
{% endhighlight %}

##### getReadLockCount 获取读锁数量

{% highlight java linenos %}

// status monitoring methods

/**
    * Returns combined state-held and overflow read count for given
    * state s.
    */
private int getReadLockCount(long s) {
    long readers;
    if ((readers = s & RBITS /*0111_1111*/) >= RFULL /*0111_1110*/)
        readers = RFULL /*0111_1110*/ + readerOverflow;
    return (int) readers;
}
{% endhighlight %}


##### isWriteLocked 判断当前是否是写锁

{% highlight java linenos %}

/**
    * Returns {@code true} if the lock is currently held exclusively.
    *
    * @return {@code true} if the lock is currently held exclusively
    */
public boolean isWriteLocked() {
    return (state & WBIT /*1000_0000*/) != 0L;
}
{% endhighlight %}


##### isReadLocked 判断当前是否有读锁

{% highlight java linenos %}

/**
    * Returns {@code true} if the lock is currently held non-exclusively.
    *
    * @return {@code true} if the lock is currently held non-exclusively
    */
public boolean isReadLocked() {
    return (state & RBITS /*0111_1111*/) != 0L;
}
{% endhighlight %}


##### isWriteLockStamp 判断stamp是否是写锁


{% highlight java linenos %}

/**
    * Tells whether a stamp represents holding a lock exclusively.
    * This method may be useful in conjunction with
    * {@link #tryConvertToWriteLock}, for example: <pre> {@code
    * long stamp = sl.tryOptimisticRead();
    * try {
    *   ...
    *   stamp = sl.tryConvertToWriteLock(stamp);
    *   ...
    * } finally {
    *   if (StampedLock.isWriteLockStamp(stamp))
    *     sl.unlockWrite(stamp);
    * }}</pre>
    *
    * @param stamp a stamp returned by a previous StampedLock operation
    * @return {@code true} if the stamp was returned by a successful
    *   write-lock operation
    * @since 10
    */
public static boolean isWriteLockStamp(long stamp) {
    return (stamp & ABITS /*1111_1111*/) == WBIT /*1000_0000*/;
}
{% endhighlight %}


##### isReadLockStamp 判断stamp是否有读锁

{% highlight java linenos %}

/**
    * Tells whether a stamp represents holding a lock non-exclusively.
    * This method may be useful in conjunction with
    * {@link #tryConvertToReadLock}, for example: <pre> {@code
    * long stamp = sl.tryOptimisticRead();
    * try {
    *   ...
    *   stamp = sl.tryConvertToReadLock(stamp);
    *   ...
    * } finally {
    *   if (StampedLock.isReadLockStamp(stamp))
    *     sl.unlockRead(stamp);
    * }}</pre>
    *
    * @param stamp a stamp returned by a previous StampedLock operation
    * @return {@code true} if the stamp was returned by a successful
    *   read-lock operation
    * @since 10
    */
public static boolean isReadLockStamp(long stamp) {
    return (stamp & RBITS /*0111_1111*/) != 0L;
}
{% endhighlight %}

##### isLockStamp 判断stamp是否有锁


{% highlight java linenos %}

/**
    * Tells whether a stamp represents holding a lock.
    * This method may be useful in conjunction with
    * {@link #tryConvertToReadLock} and {@link #tryConvertToWriteLock},
    * for example: <pre> {@code
    * long stamp = sl.tryOptimisticRead();
    * try {
    *   ...
    *   stamp = sl.tryConvertToReadLock(stamp);
    *   ...
    *   stamp = sl.tryConvertToWriteLock(stamp);
    *   ...
    * } finally {
    *   if (StampedLock.isLockStamp(stamp))
    *     sl.unlock(stamp);
    * }}</pre>
    *
    * @param stamp a stamp returned by a previous StampedLock operation
    * @return {@code true} if the stamp was returned by a successful
    *   read-lock or write-lock operation
    * @since 10
    */
public static boolean isLockStamp(long stamp) {
    return (stamp & ABITS /*1111_1111*/) != 0L;
}
{% endhighlight %}


##### isOptimisticReadStamp 判断stamp是否是乐观锁

{% highlight java linenos %}

/**
    * Tells whether a stamp represents a successful optimistic read.
    *
    * @param stamp a stamp returned by a previous StampedLock operation
    * @return {@code true} if the stamp was returned by a successful
    *   optimistic read operation, that is, a non-zero return from
    *   {@link #tryOptimisticRead()} or
    *   {@link #tryConvertToOptimisticRead(long)}
    * @since 10
    */
public static boolean isOptimisticReadStamp(long stamp) {
    return (stamp & ABITS /*1111_1111*/) == 0L && stamp != 0L;
}
{% endhighlight %}



##### getReadLockCount

{% highlight java linenos %}

/**
    * Queries the number of read locks held for this lock. This
    * method is designed for use in monitoring system state, not for
    * synchronization control.
    * @return the number of read locks held
    */
public int getReadLockCount() {
    return getReadLockCount(state);
}
{% endhighlight %}


##### asReadLock 将StampLock当作普通读锁用

{% highlight java linenos %}

// views

/**
    * Returns a plain {@link Lock} view of this StampedLock in which
    * the {@link Lock#lock} method is mapped to {@link #readLock},
    * and similarly for other methods. The returned Lock does not
    * support a {@link Condition}; method {@link Lock#newCondition()}
    * throws {@code UnsupportedOperationException}.
    *
    * @return the lock
    */
public Lock asReadLock() {
    ReadLockView v;
    if ((v = readLockView) != null) return v;
    return readLockView = new ReadLockView();
}
{% endhighlight %}

##### asWriteLock 将StampLock当作普通写锁用

{% highlight java linenos %}

/**
    * Returns a plain {@link Lock} view of this StampedLock in which
    * the {@link Lock#lock} method is mapped to {@link #writeLock},
    * and similarly for other methods. The returned Lock does not
    * support a {@link Condition}; method {@link Lock#newCondition()}
    * throws {@code UnsupportedOperationException}.
    *
    * @return the lock
    */
public Lock asWriteLock() {
    WriteLockView v;
    if ((v = writeLockView) != null) return v;
    return writeLockView = new WriteLockView();
}
{% endhighlight %}


##### asReadWriteLock 将StampLock当作普通读写锁用

{% highlight java linenos %}

/**
    * Returns a {@link ReadWriteLock} view of this StampedLock in
    * which the {@link ReadWriteLock#readLock()} method is mapped to
    * {@link #asReadLock()}, and {@link ReadWriteLock#writeLock()} to
    * {@link #asWriteLock()}.
    *
    * @return the lock
    */
public ReadWriteLock asReadWriteLock() {
    ReadWriteLockView v;
    if ((v = readWriteLockView) != null) return v;
    return readWriteLockView = new ReadWriteLockView();
}
{% endhighlight %}

##### ReadLockView 将StampLock当作普通读锁用

{% highlight java linenos %}

// view classes

final class ReadLockView implements Lock {
    public void lock() { readLock(); }
    public void lockInterruptibly() throws InterruptedException {
        readLockInterruptibly();
    }
    public boolean tryLock() { return tryReadLock() != 0L; }
    public boolean tryLock(long time, TimeUnit unit)
        throws InterruptedException {
        return tryReadLock(time, unit) != 0L;
    }
    public void unlock() { unstampedUnlockRead(); }
    public Condition newCondition() {
        throw new UnsupportedOperationException();
    }
}
{% endhighlight %}


##### WriteLockView 将StampLock当作普通写锁用

{% highlight java linenos %}

final class WriteLockView implements Lock {
    public void lock() { writeLock(); }
    public void lockInterruptibly() throws InterruptedException {
        writeLockInterruptibly();
    }
    public boolean tryLock() { return tryWriteLock() != 0L; }
    public boolean tryLock(long time, TimeUnit unit)
        throws InterruptedException {
        return tryWriteLock(time, unit) != 0L;
    }
    public void unlock() { unstampedUnlockWrite(); }
    public Condition newCondition() {
        throw new UnsupportedOperationException();
    }
}
{% endhighlight %}



##### ReadWriteLockView 将StampLock当作普通读写锁用

{% highlight java linenos %}

final class ReadWriteLockView implements ReadWriteLock {
    public Lock readLock() { return asReadLock(); }
    public Lock writeLock() { return asWriteLock(); }
}
{% endhighlight %}

##### 支持序列化

{% highlight java linenos %}

private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    s.defaultReadObject();
    state = ORIGIN; // reset to unlocked state
}
{% endhighlight %}


##### tryIncReaderOverflow 读锁溢出到readerOverflow

{% highlight java linenos %}

// overflow handling methods

/**
    * Tries to increment readerOverflow by first setting state
    * access bits value to RBITS /*0111_1111*/, indicating hold of spinlock,
    * then updating, then releasing.
    *
    * @param s a reader overflow stamp: (s & ABITS /*1111_1111*/) >= RFULL /*0111_1110*/
    * @return new stamp on success, else zero
    */
private long tryIncReaderOverflow(long s) {
    // assert (s & ABITS /*1111_1111*/) >= RFULL /*0111_1110*/;
    if ((s & ABITS /*1111_1111*/) != RFULL /*0111_1110*/)
        Thread.onSpinWait();
    else if (casState(s, s | RBITS /*0111_1111*/)) {
        ++readerOverflow;
        return state = s;
    }
    return 0L;
}
{% endhighlight %}


##### tryDecReaderOverflow 将读锁溢出到readerOverflow值减掉

{% highlight java linenos %}

/**
    * Tries to decrement readerOverflow.
    *
    * @param s a reader overflow stamp: (s & ABITS /*1111_1111*/) >= RFULL /*0111_1110*/
    * @return new stamp on success, else zero
    */
private long tryDecReaderOverflow(long s) {
    // assert (s & ABITS /*1111_1111*/) >= RFULL /*0111_1110*/;
    if ((s & ABITS /*1111_1111*/) != RFULL /*0111_1110*/)
        Thread.onSpinWait();
    else if (casState(s, s | RBITS /*0111_1111*/)) {
        int r; long nextState;
        if ((r = readerOverflow) > 0) {
            readerOverflow = r - 1;
            nextState = s;
        }
        else
            nextState = s - RUNIT;
        return state = nextState;
    }
    return 0L;
}
{% endhighlight %}


##### signalNext 唤醒主队列中等待的节点


{% highlight java linenos %}

// release methods

/**
    * Wakes up the successor of given node, if one exists, and unsets its
    * WAITING status to avoid park race. This may fail to wake up an
    * eligible thread when one or more have been cancelled, but
    * cancelAcquire ensures liveness.
    */
static final void signalNext(Node h) {
    Node s;
    if (h != null && (s = h.next) != null && s.status > 0) {
        s.getAndUnsetStatus(WAITING);
        LockSupport.unpark(s.waiter);
    }
}
{% endhighlight %}

##### signalCowaiters 某个读节点的等待队列中的节点

{% highlight java linenos %}

/**
    * Removes and unparks all cowaiters of node, if it exists.
    */
private static void signalCowaiters(ReaderNode node) {
    if (node != null) {
        for (ReaderNode c; (c = node.cowaiters) != null; ) {
            if (node.casCowaiters(c, c.cowaiters))
                LockSupport.unpark(c.waiter);
        }
    }
}
{% endhighlight %}

##### casTail 设置队尾

{% highlight java linenos %}

// queue link methods
private boolean casTail(Node c, Node v) {
    return U.compareAndSetReference(this, TAIL, c, v);
}

{% endhighlight %}


##### tryInitializeHead 初始化队列

{% highlight java linenos %}

/** tries once to CAS a new dummy node for head */
private void tryInitializeHead() {
    Node h = new WriterNode();
    if (U.compareAndSetReference(this, HEAD, null, h))
        tail = h;
}
{% endhighlight %}

##### acquireWrite 排队并尝试获取写锁

{% highlight java linenos %}

/**
    * For explanation, see above and AbstractQueuedSynchronizer
    * internal documentation.
    *
    * @param interruptible true if should check interrupts and if so
    * return INTERRUPTED
    * @param timed if true use timed waits
    * @param time the System.nanoTime value to timeout at (and return zero)
    * @return next state, or INTERRUPTED
    */
private long acquireWrite(boolean interruptible, boolean timed, long time) {
    byte spins = 0, postSpins = 0;   // retries upon unpark of first thread
    boolean interrupted = false, first = false;
    WriterNode node = null;
    Node pred = null;
    for (long s, nextState;;) {
        if (!first && (pred = (node == null) ? null : node.prev) != null &&
            !(first = (head == pred))) {
            if (pred.status < 0) {
                cleanQueue();           // predecessor cancelled
                continue;
            } else if (pred.prev == null) {
                Thread.onSpinWait();    // ensure serialization
                continue;
            }
        }
        if ((first || pred == null) && ((s = state) & ABITS /*1111_1111*/) == 0L &&
            casState(s, nextState = s | WBIT /*1000_0000*/)) {
            U.storeStoreFence();
            if (first) {
                node.prev = null;
                head = node;
                pred.next = null;
                node.waiter = null;
                if (interrupted)
                    Thread.currentThread().interrupt();
            }
            return nextState;
        } else if (node == null) {          // retry before enqueuing
            node = new WriterNode();
        } else if (pred == null) {          // try to enqueue
            Node t = tail;
            node.setPrevRelaxed(t);
            if (t == null)
                tryInitializeHead();
            else if (!casTail(t, node))
                node.setPrevRelaxed(null);  // back out
            else
                t.next = node;
        } else if (first && spins != 0) {   // reduce unfairness
            --spins;
            Thread.onSpinWait();
        } else if (node.status == 0) {      // enable signal
            if (node.waiter == null)
                node.waiter = Thread.currentThread();
            node.status = WAITING;
        } else {
            long nanos;
            spins = postSpins = (byte)((postSpins << 1) | 1);
            if (!timed)
                LockSupport.park(this);
            else if ((nanos = time - System.nanoTime()) > 0L)
                LockSupport.parkNanos(this, nanos);
            else
                break;
            node.clearStatus();
            if ((interrupted |= Thread.interrupted()) && interruptible)
                break;
        }
    }
    return cancelAcquire(node, interrupted);
}
{% endhighlight %}

##### acquireRead 排队并尝试获取读锁

{% highlight java linenos %}

/**
    * See above for explanation.
    *
    * @param interruptible true if should check interrupts and if so
    * return INTERRUPTED
    * @param timed if true use timed waits
    * @param time the System.nanoTime value to timeout at (and return zero)
    * @return next state, or INTERRUPTED
    */
private long acquireRead(boolean interruptible, boolean timed, long time) {
    boolean interrupted = false;
    ReaderNode node = null;
    /*
        * Loop:
        *   if empty, try to acquire
        *   if tail is Reader, try to cowait; restart if leader stale or cancels
        *   else try to create and enqueue node, and wait in 2nd loop below
        */
    for (;;) {
        ReaderNode leader; long nextState;
        Node tailPred = null, t = tail;
        if ((t == null || (tailPred = t.prev) == null) &&
            (nextState = tryAcquireRead()) != 0L) // try now if empty
            return nextState;
        else if (t == null)
            tryInitializeHead();
        else if (tailPred == null || !(t instanceof ReaderNode)) {
            if (node == null)
                node = new ReaderNode();
            if (tail == t) {
                node.setPrevRelaxed(t);
                if (casTail(t, node)) {
                    t.next = node;
                    break; // node is leader; wait in loop below
                }
                node.setPrevRelaxed(null);
            }
        } else if ((leader = (ReaderNode)t) == tail) { // try to cowait
            for (boolean attached = false;;) {
                if (leader.status < 0 || leader.prev == null)
                    break;
                else if (node == null)
                    node = new ReaderNode();
                else if (node.waiter == null)
                    node.waiter = Thread.currentThread();
                else if (!attached) {
                    ReaderNode c = leader.cowaiters;
                    node.setCowaitersRelaxed(c);
                    attached = leader.casCowaiters(c, node);
                    if (!attached)
                        node.setCowaitersRelaxed(null);
                } else {
                    long nanos = 0L;
                    if (!timed)
                        LockSupport.park(this);
                    else if ((nanos = time - System.nanoTime()) > 0L)
                        LockSupport.parkNanos(this, nanos);
                    interrupted |= Thread.interrupted();
                    if ((interrupted && interruptible) ||
                        (timed && nanos <= 0L))
                        return cancelCowaiter(node, leader, interrupted);
                }
            }
            if (node != null)
                node.waiter = null;
            long ns = tryAcquireRead();
            signalCowaiters(leader);
            if (interrupted)
                Thread.currentThread().interrupt();
            if (ns != 0L)
                return ns;
            else
                node = null; // restart if stale, missed, or leader cancelled
        }
    }

    // node is leader of a cowait group; almost same as acquireWrite
    byte spins = 0, postSpins = 0;   // retries upon unpark of first thread
    boolean first = false;
    Node pred = null;
    for (long nextState;;) {
        if (!first && (pred = node.prev) != null &&
            !(first = (head == pred))) {
            if (pred.status < 0) {
                cleanQueue();           // predecessor cancelled
                continue;
            } else if (pred.prev == null) {
                Thread.onSpinWait();    // ensure serialization
                continue;
            }
        }
        if ((first || pred == null) &&
            (nextState = tryAcquireRead()) != 0L) {
            if (first) {
                node.prev = null;
                head = node;
                pred.next = null;
                node.waiter = null;
            }
            signalCowaiters(node);
            if (interrupted)
                Thread.currentThread().interrupt();
            return nextState;
        } else if (first && spins != 0) {
            --spins;
            Thread.onSpinWait();
        } else if (node.status == 0) {
            if (node.waiter == null)
                node.waiter = Thread.currentThread();
            node.status = WAITING;
        } else {
            long nanos;
            spins = postSpins = (byte)((postSpins << 1) | 1);
            if (!timed)
                LockSupport.park(this);
            else if ((nanos = time - System.nanoTime()) > 0L)
                LockSupport.parkNanos(this, nanos);
            else
                break;
            node.clearStatus();
            if ((interrupted |= Thread.interrupted()) && interruptible)
                break;
        }
    }
    return cancelAcquire(node, interrupted);
}
{% endhighlight %}


##### cleanQueue 将取消状态的节点清理出队列


{% highlight java linenos %}

// Cancellation support

/**
    * Possibly repeatedly traverses from tail, unsplicing cancelled
    * nodes until none are found. Unparks nodes that may have been
    * relinked to be next eligible acquirer.
    */
private void cleanQueue() {
    for (;;) {                               // restart point
        for (Node q = tail, s = null, p, n;;) { // (p, q, s) triples
            if (q == null || (p = q.prev) == null)
                return;                      // end of list
            if (s == null ? tail != q : (s.prev != q || s.status < 0))
                break;                       // inconsistent
            if (q.status < 0) {              // cancelled
                if ((s == null ? casTail(q, p) : s.casPrev(q, p)) &&
                    q.prev == p) {
                    p.casNext(q, s);         // OK if fails
                    if (p.prev == null)
                        signalNext(p);
                }
                break;
            }
            if ((n = p.next) != q) {         // help finish
                if (n != null && q.prev == p && q.status >= 0) {
                    p.casNext(n, q);
                    if (p.prev == null)
                        signalNext(p);
                }
                break;
            }
            s = q;
            q = q.prev;
        }
    }
}

{% endhighlight %}


##### unlinkCowaiter 将取消状态的节点清理出队列


{% highlight java linenos %}
/**
    * If leader exists, possibly repeatedly traverses cowaiters,
    * unsplicing the given cancelled node until not found.
    */
private void unlinkCowaiter(ReaderNode node, ReaderNode leader) {
    if (leader != null) {
        while (leader.prev != null && leader.status >= 0) {
            for (ReaderNode p = leader, q; ; p = q) {
                if ((q = p.cowaiters) == null)
                    return;
                if (q == node) {
                    p.casCowaiters(q, q.cowaiters);
                    break;  // recheck even if succeeded
                }
            }
        }
    }
}
{% endhighlight %}


##### cancelAcquire 取消排队

如果当前节点为读节点，则唤醒后续节点


{% highlight java linenos %}

/**
    * If node non-null, forces cancel status and unsplices it from
    * queue, wakes up any cowaiters, and possibly wakes up successor
    * to recheck status.
    *
    * @param node the waiter (may be null if not yet enqueued)
    * @param interrupted if already interrupted
    * @return INTERRUPTED if interrupted or Thread.interrupted, else zero
    */
private long cancelAcquire(Node node, boolean interrupted) {
    if (node != null) {
        node.waiter = null;
        node.status = CANCELLED;
        cleanQueue();
        if (node instanceof ReaderNode)
            signalCowaiters((ReaderNode)node);
    }
    return (interrupted || Thread.interrupted()) ? INTERRUPTED : 0L;
}
{% endhighlight %}


##### cancelCowaiter 取消读节点


{% highlight java linenos %}

/**
    * If node non-null, forces cancel status and unsplices from
    * leader's cowaiters list unless/until it is also cancelled.
    *
    * @param node if non-null, the waiter
    * @param leader if non-null, the node heading cowaiters list
    * @param interrupted if already interrupted
    * @return INTERRUPTED if interrupted or Thread.interrupted, else zero
    */
private long cancelCowaiter(ReaderNode node, ReaderNode leader,
                            boolean interrupted) {
    if (node != null) {
        node.waiter = null;
        node.status = CANCELLED;
        unlinkCowaiter(node, leader);
    }
    return (interrupted || Thread.interrupted()) ? INTERRUPTED : 0L;
}

{% endhighlight %}
